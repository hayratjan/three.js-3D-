<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particle System</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        .glass-panel {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #video-input {
            transform: scaleX(-1);
            display: none; /* Processing happens in background */
        }
        /* Custom Scrollbar for the panel */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    </style>
</head>
<body>
    <!-- Video Element for MediaPipe (Hidden) -->
    <video id="video-input"></video>
    <!-- Main UI Container -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none z-10">
        
        <!-- Header / Status -->
        <div class="absolute top-4 left-6 pointer-events-auto">
            <h1 class="text-white text-2xl font-light tracking-wider mb-1">PARTICLE<span class="font-bold text-blue-400">FLOW</span></h1>
            <div class="flex items-center gap-2 text-xs text-gray-400">
                <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500"></div>
                <span id="status-text">Waiting for camera...</span>
            </div>
        </div>
        <!-- Control Panel -->
        <div class="absolute top-4 right-4 w-64 glass-panel rounded-xl p-5 pointer-events-auto transition-all duration-300 hover:bg-opacity-80">
            <h2 class="text-white text-sm font-bold uppercase tracking-widest mb-4 border-b border-gray-700 pb-2">Controls</h2>
            
            <!-- Shape Selection -->
            <div class="mb-5">
                <label class="text-gray-400 text-xs block mb-2">SHAPE MODE</label>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="setShape('heart')" class="shape-btn bg-gray-800 hover:bg-blue-600 text-white text-xs py-2 rounded transition-colors border border-gray-700">Heart</button>
                    <button onclick="setShape('flower')" class="shape-btn bg-gray-800 hover:bg-blue-600 text-white text-xs py-2 rounded transition-colors border border-gray-700">Flower</button>
                    <button onclick="setShape('saturn')" class="shape-btn bg-gray-800 hover:bg-blue-600 text-white text-xs py-2 rounded transition-colors border border-gray-700">Saturn</button>
                    <button onclick="setShape('buddha')" class="shape-btn bg-gray-800 hover:bg-blue-600 text-white text-xs py-2 rounded transition-colors border border-gray-700">Buddha</button>
                    <button onclick="setShape('fireworks')" class="shape-btn col-span-2 bg-gray-800 hover:bg-purple-600 text-white text-xs py-2 rounded transition-colors border border-gray-700">Fireworks</button>
                </div>
            </div>
            <!-- Color Picker -->
            <div class="mb-5">
                <label class="text-gray-400 text-xs block mb-2">PARTICLE COLOR</label>
                <div class="flex items-center gap-3">
                    <input type="color" id="color-picker" value="#00ffff" class="w-8 h-8 p-0 border-0 rounded cursor-pointer bg-transparent">
                    <span id="color-hex" class="text-gray-300 text-xs font-mono">#00FFFF</span>
                </div>
            </div>
            <!-- Info -->
            <div class="mb-5 text-xs text-gray-500 leading-relaxed">
                <p class="mb-1"><strong class="text-gray-300">One Hand:</strong> Pinch to pulse.</p>
                <p><strong class="text-gray-300">Two Hands:</strong> Move apart to expand & zoom.</p>
            </div>
            <!-- Fullscreen -->
            <button id="fullscreen-btn" class="w-full bg-gray-700 hover:bg-gray-600 text-white text-xs py-2 rounded transition-colors flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                Toggle Fullscreen
            </button>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        // --- Configuration ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.15;
        const CAMERA_Z_BASE = 30;
        // --- State ---
        const state = {
            currentShape: 'heart',
            targetColor: new THREE.Color(0x00ffff),
            currentColor: new THREE.Color(0x00ffff),
            handDistance: 0, // Normalized 0 to 1
            pinchStrength: 0, // Normalized 0 to 1
            handsDetected: 0,
            expansion: 1.0,
            rotationSpeed: 0.001
        };
        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CAMERA_Z_BASE;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        // --- Particle System ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // Initialize with random positions
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        // Shader Material for better looking particles
        const material = new THREE.PointsMaterial({
            color: state.currentColor,
            size: PARTICLE_SIZE,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);
        // --- Shape Generators ---
        const Shapes = {
            heart: (i) => {
                const t = Math.random() * Math.PI * 2;
                // Distribution strategy: Random selection often clusters too much, 
                // so we distribute somewhat uniformly but with random noise
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                // Add volume
                const z = (Math.random() - 0.5) * 5;
                // Scale down
                return [x * 0.5, y * 0.5, z];
            },
            flower: (i) => {
                // Rose curve in 3D
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 5 * Math.sin(4 * theta) + 8; 
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi) * 0.5; // Flatten slightly
                return [x, y, z];
            },
            saturn: (i) => {
                // Mix of sphere and ring
                const isRing = Math.random() > 0.4;
                if (isRing) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 12 + Math.random() * 6;
                    return [Math.cos(angle) * radius, (Math.random()-0.5), Math.sin(angle) * radius];
                } else {
                    // Planet body
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const r = 8;
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);
                    return [x, y, z];
                }
            },
            buddha: (i) => {
                // Abstract representation using geometric primitives (Sphere for head, Cone/Cylinder for body, Torus/Oval for legs)
                const section = Math.random();
                
                if (section < 0.15) { 
                    // Head
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const r = 2.5;
                    return [r * Math.sin(phi) * Math.cos(theta), 6 + r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
                } else if (section < 0.5) {
                    // Body (Ellipsoid)
                    const angle = Math.random() * Math.PI * 2;
                    const h = (Math.random() - 0.5) * 8; // Height -4 to 4
                    const w = 4.5 * (1 - Math.abs(h)/5); // Tapered
                    return [Math.cos(angle) * w, h + 1, Math.sin(angle) * w];
                } else {
                    // Legs/Base (Lotus position abstract - flattened torus)
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    const R = 5; 
                    const r = 2.5;
                    const x = (R + r * Math.cos(v)) * Math.cos(u);
                    const y = -4 + r * Math.sin(v) * 0.5; // Flattened height
                    const z = (R + r * Math.cos(v)) * Math.sin(u);
                    return [x, y, z];
                }
            },
            fireworks: (i) => {
                // Sphere explosion
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                // Vary radius significantly for explosion look
                const r = Math.random() * 25;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                return [x, y, z];
            }
        };
        // Generate points logic
        function generateShape(shapeName) {
            const generator = Shapes[shapeName] || Shapes.heart;
            
            // Special handling for fireworks (dynamic regen) or static shapes
            // But for simplicity in this unified loop, we pre-calculate random spots for fireworks too
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const [x, y, z] = generator(i);
                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;
            }
        }
        // Initial shape
        generateShape('heart');
        // --- MediaPipe Hands Setup ---
        const videoElement = document.getElementById('video-input');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        function onResults(results) {
            state.handsDetected = 0;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handsDetected = results.multiHandLandmarks.length;
                statusDot.classList.remove('bg-red-500');
                statusDot.classList.add('bg-green-500');
                statusText.innerText = `${state.handsDetected} Hand(s) Tracking`;
                // Logic for 2 hands
                if (results.multiHandLandmarks.length === 2) {
                    const hand1 = results.multiHandLandmarks[0][0]; // Wrist
                    const hand2 = results.multiHandLandmarks[1][0]; // Wrist
                    
                    // Calculate distance between wrists
                    const dx = hand1.x - hand2.x;
                    const dy = hand1.y - hand2.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Map distance (approx 0.1 to 0.8) to expansion (0.5 to 3.0)
                    // Smoothly lerp the value
                    state.handDistance = distance;
                    const targetExp = Math.max(0.5, Math.min(3.5, distance * 4));
                    state.expansion += (targetExp - state.expansion) * 0.1;
                }
                // Logic for 1 hand (Pinch for Pulse/Scale)
                else if (results.multiHandLandmarks.length === 1) {
                    const hand = results.multiHandLandmarks[0];
                    const thumb = hand[4];
                    const index = hand[8];
                    
                    const dist = Math.sqrt(
                        Math.pow(thumb.x - index.x, 2) + 
                        Math.pow(thumb.y - index.y, 2)
                    );
                    
                    // Normal pinch is around 0.02 (closed) to 0.2 (open)
                    state.pinchStrength = dist;
                    const targetExp = 0.8 + (dist * 5); // base 0.8 + extra
                    state.expansion += (targetExp - state.expansion) * 0.1;
                }
            } else {
                statusDot.classList.remove('bg-green-500');
                statusDot.classList.add('bg-yellow-500');
                statusText.innerText = "Looking for hands...";
                
                // Reset slowly to base expansion
                state.expansion += (1.0 - state.expansion) * 0.05;
            }
        }
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        cameraUtils.start().then(() => {
            console.log("Camera started");
        }).catch(e => {
            console.error("Camera failed", e);
            statusText.innerText = "Camera access denied/error";
        });
        // --- UI Handlers ---
        window.setShape = (shape) => {
            state.currentShape = shape;
            generateShape(shape);
            
            // Update UI Buttons
            document.querySelectorAll('.shape-btn').forEach(btn => {
                if(btn.innerText.toLowerCase() === shape) {
                    btn.classList.add('bg-blue-600', 'border-blue-400');
                    btn.classList.remove('bg-gray-800', 'border-gray-700');
                } else {
                    btn.classList.remove('bg-blue-600', 'border-blue-400');
                    btn.classList.add('bg-gray-800', 'border-gray-700');
                }
            });
        };
        // Init default button state
        window.setShape('heart');
        const colorPicker = document.getElementById('color-picker');
        const colorHex = document.getElementById('color-hex');
        
        colorPicker.addEventListener('input', (e) => {
            const val = e.target.value;
            colorHex.innerText = val.toUpperCase();
            state.targetColor.set(val);
        });
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });
        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();
            // Color Interpolation
            state.currentColor.lerp(state.targetColor, 0.05);
            material.color = state.currentColor;
            // Rotate entire system slowly
            particles.rotation.y += state.rotationSpeed + (state.expansion * 0.001);
            
            // Specialized behavior for Fireworks (auto explode/pulse)
            let expansionFactor = state.expansion;
            if (state.currentShape === 'fireworks') {
                 expansionFactor *= (1 + Math.sin(time * 2) * 0.3);
            } else if (state.currentShape === 'heart') {
                 // Heartbeat
                 expansionFactor *= (1 + Math.sin(time * 8) * 0.05 * (1 - Math.min(1, state.pinchStrength*2))); // Beat faster if closed hand? No just subtle beat
            }
            const posAttribute = geometry.attributes.position;
            const currentPositions = posAttribute.array;
            // Particle Physics/Update
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;
                let tx = targetPositions[ix];
                let ty = targetPositions[iy];
                let tz = targetPositions[iz];
                // Apply Expansion from Hand Tracking
                tx *= expansionFactor;
                ty *= expansionFactor;
                tz *= expansionFactor;
                // Add subtle noise movement
                tx += Math.sin(time + i) * 0.05;
                ty += Math.cos(time + i * 0.5) * 0.05;
                // Lerp towards target (Ease out)
                // Speed depends on distance
                currentPositions[ix] += (tx - currentPositions[ix]) * 0.08;
                currentPositions[iy] += (ty - currentPositions[iy]) * 0.08;
                currentPositions[iz] += (tz - currentPositions[iz]) * 0.08;
            }
            posAttribute.needsUpdate = true;
            // Camera drift (interactive parallax based on mouse could be added, but hands are focus)
            
            renderer.render(scene, camera);
        }
        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>